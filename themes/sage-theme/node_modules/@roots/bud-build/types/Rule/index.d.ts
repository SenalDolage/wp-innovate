import { Framework, Item, Maybe, Rule as FrameworkRule } from '@roots/bud-framework';
import { Base } from '../shared/Base';
/**
 * Framework Rule
 *
 * @public
 */
export declare class Rule extends Base implements FrameworkRule.Interface {
    app: Framework;
    /**
     * {@inheritDoc @roots/bud-framework#Rule.Abstract.test}
     *
     * @public
     */
    test?: (app: Framework) => RegExp;
    /**
     * {@inheritDoc @roots/bud-framework#Rule.Abstract.use}
     *
     * @public
     */
    use?: (app: Framework) => Item.Interface[];
    /**
     * Include paths
     */
    include?: (app: Framework) => Array<string | RegExp>;
    /**
     * {@inheritDoc @roots/bud-framework#Rule.Abstract.exclude}
     *
     * @public
     */
    exclude?: (app: Framework) => Array<string | RegExp>;
    /**
     * {@inheritDoc @roots/bud-framework#Rule.Abstract."type"}
     *
     * @public
     */
    type?: (app: Framework) => string;
    /**
     * Generator factory
     *
     * @public
     */
    parser?: (app: Framework) => FrameworkRule.Parser;
    /**
     * Generator factory
     *
     * @public
     */
    generator?: (app: Framework) => any;
    /**
     * Class constructor
     *
     * @public
     */
    constructor(app: Framework, options: FrameworkRule.Options);
    /**
     * Test value
     *
     * @param app - Framework instance
     *
     * @public
     * @decorator `@bind`
     */
    getTest(): RegExp;
    /**
     * Set test value
     *
     * @public
     * @decorator `@bind`
     */
    setTest(test: RegExp | (() => RegExp)): Rule;
    /**
     * Get parser value
     *
     * @public
     * @decorator `@bind`
     */
    getParser(): FrameworkRule.Parser;
    /**
     * Set parser value
     *
     * @public
     * @decorator `@bind`
     */
    setParser(parser: Maybe<[Framework], FrameworkRule.Parser>): Rule;
    /**
     * Get use value
     *
     * @public
     * @decorator `@bind`
     */
    getUse(): Item.Interface[];
    /**
     * Set use value
     *
     * @public
     * @decorator `@bind`
     */
    setUse(use: Maybe<[Framework], Item.Interface[]>): Rule;
    /**
     * Get exclude value
     *
     * @public
     * @decorator `@bind`
     */
    getInclude(): Array<string | RegExp>;
    /**
     * Set exclude value
     *
     * @public
     * @decorator `@bind`
     */
    setInclude(include: Maybe<[Framework], Array<string | RegExp>>): Rule;
    /**
     * Get exclude value
     *
     * @public
     * @decorator `@bind`
     */
    getExclude(): Array<string | RegExp>;
    /**
     * Set exclude value
     *
     * @public
     * @decorator `@bind`
     */
    setExclude(exclude: Maybe<[Framework], Array<string | RegExp>>): Rule;
    /**
     * Get type value
     *
     * @public
     * @decorator `@bind`
     */
    getType(): string;
    /**
     * Set type value
     *
     * @public
     * @decorator `@bind`
     */
    setType(type: any): Rule;
    /**
     * Get generator value
     *
     * @public
     * @decorator `@bind`
     */
    getGenerator(): any;
    /**
     * Set generator value
     *
     * @public
     * @decorator `@bind`
     */
    setGenerator(generator: FrameworkRule.Interface['generator'] | ((app: Framework) => FrameworkRule.Interface['generator'])): Rule;
    /**
     * Produce final Base output
     *
     * @param app - {@link @roots/bud-framework#Framework}
     * @returns finalized rule
     *
     * @public
     * @decorator `@bind`
     */
    make(): Partial<{
        test: RegExp;
        use?: {
            loader: string;
            options?: {
                [key: string]: any;
            };
        }[];
        exclude?: RegExp;
        type?: string;
        parser?: FrameworkRule.Parser;
        generator?: any;
    }>;
}
//# sourceMappingURL=index.d.ts.map