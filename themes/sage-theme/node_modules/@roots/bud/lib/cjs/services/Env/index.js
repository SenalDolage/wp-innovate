"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Env = void 0;
const bud_framework_1 = require("@roots/bud-framework");
const bud_support_1 = require("@roots/bud-support");
const { isString } = bud_support_1.lodash;
/**
 * Env service
 *
 * @public
 */
class Env extends bud_framework_1.Service {
    constructor() {
        super(...arguments);
        /**
         * Service ident
         *
         * @internal
         */
        this.ident = 'env';
    }
    /**
     * Path to .env file
     *
     * @public @readonly
     */
    get envPath() {
        return this.app.path('project', '.env');
    }
    /**
     * Bootstrap event callback
     *
     * @internal
     * @decorator `@bind`
     */
    async bootstrap() {
        const values = this.getParsedEnv();
        this.log('log', { message: 'loading env', values });
        if (values)
            this.setStore(values);
        if (this.isEmpty()) {
            this.log('warn', 'no env values found');
        }
        this.getEntries().forEach(([k, v]) => {
            this.log('log', `value set`, k, '=', v);
        });
    }
    /**
     * Retrieve parsed env object
     *
     * @public
     * @decorator `@bind`
     */
    getParsedEnv() {
        const raw = bud_support_1.dotenv.config({ path: this.envPath });
        if (!raw)
            return {};
        const { parsed, error } = raw;
        if (error || !parsed)
            return {};
        const expanded = (0, bud_support_1.dotenvExpand)(parsed);
        if (!expanded)
            return {};
        return expanded;
    }
    /**
     * Get entries from .env which include `APP_PUBLIC` in their name
     *
     * @public
     * @decorator `@bind`
     */
    getPublicEnv() {
        this.log('log', 'getting publicEnv', this.all());
        if (this.isEmpty()) {
            return {};
        }
        return this.getEntries()
            .filter(([k, v]) => {
            if (!k)
                return false;
            const isPublic = k.startsWith('PUBLIC_');
            if (!isPublic)
                return false;
            this.log('log', {
                message: 'public env',
                suffix: JSON.stringify({ key: k, value: v, isPublic }),
            });
            return isPublic;
        })
            .map(([rawKey, rawValue]) => {
            const interpolated = rawKey.replace('PUBLIC_', '');
            const value = isString(rawValue)
                ? rawValue
                : JSON.stringify(rawValue);
            this.log('log', {
                message: `public env retrieved ${interpolated} => ${value}`,
            });
            return [interpolated, value];
        })
            .reduce((a, [k, v]) => ({ ...a, [k]: v }), {});
    }
}
__decorate([
    bud_support_1.bind
], Env.prototype, "bootstrap", null);
__decorate([
    bud_support_1.bind
], Env.prototype, "getParsedEnv", null);
__decorate([
    bud_support_1.bind,
    bud_support_1.once
], Env.prototype, "getPublicEnv", null);
exports.Env = Env;
